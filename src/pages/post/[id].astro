---
import { getTitle } from '../../components/SiteMeta.js'

import Framework from '../../layouts/Framework.astro'
import Block from '../../components/Block.astro'

import { pageBlockFetcher, pageInfoFetcher } from '../../components/Fetchers.js'
import { pageParser } from "../../components/Parsers.js"
import { dateFormatter, iconMaker } from '../../components/Utils'

import { getPostList } from '../../components/SiteMeta.js'

import { v4 as uuidv4 } from 'uuid';
import Downloader from "nodejs-file-downloader"

const { id } = Astro.params;

export async function getStaticPaths(){
    const postList = getPostList.get()
    return postList.map((each) => {
        return {
            params: {id: each}
        }
    })
    
}

console.log("Generating page for " + id );

const pageInfoData = await pageInfoFetcher(id);
let pageCover = ''
if(pageInfoData.cover != null){
    switch(pageInfoData.cover.type){
        case 'external':
            pageCover = pageInfoData.cover.external.url;
            break;
        case 'file':
            const rdmName = uuidv4();
            const downloader = new Downloader({
                url: pageInfoData.cover.file.url,
                directory: "./dist/post/assets",
                fileName: rdmName
                });
            await downloader.download();
            pageCover = "../assets/" + rdmName;
            break;
    }
}
const pageIcon = iconMaker(pageInfoData)

let next_cursor = null;
let fullPageContents = [];
while(true){
    const pageContentData = await pageBlockFetcher(id, next_cursor);
    const pageParsedData = await pageParser(pageContentData);
    fullPageContents.push(...pageParsedData)
    if(pageContentData.has_more){
        console.log("This page has more content, fetching...")
        next_cursor = pageContentData.next_cursor;
    }else{
        break;
    }
};

function listMerger(pageContents){
    console.log("Merging list items...")
    let tmp = [];

    let index = 0;
    while(index < pageContents.length){
        if(pageContents[index].type != 'numbered_list_item' && pageContents[index].type != 'bulleted_list_item'){
                // current item is not a list block, copy and skip
                tmp.push(pageContents[index]);
                index += 1;
        }else{
            // current item is a list block
            try{
                tmp.at(-1).type;
            } catch(error){
                // if there is no item in the new list, means it is the first item from the old list, append it anyways
                tmp.push(
                    {
                        type: pageContents[index].type + "_group",
                        origin_type: pageContents[index].type,
                        items: [ pageContents[index] ],
                        children: false
                        // list gourp should not have children, only list item has children
                    }
                );
                index += 1;
                continue;
            };
            // if the new list not empty
            if( tmp.at(-1).type == pageContents[index].type + '_group'){
                // if the last item from the new list is as same as the current item from the old list
                tmp.at(-1).items.push(pageContents[index])
                index += 1;
            }else{
                // means current item is a new list type
                tmp.push(
                    {
                        type: pageContents[index].type + "_group",
                        origin_type: pageContents[index].type,
                        items: [ pageContents[index] ],
                        children: false
                    }
                );
                index += 1;
            };
        };

    };
    return tmp;
}

function listMergerHandler(pageContents){
    const mergedContent = listMerger(pageContents);
    mergedContent.forEach((block) => {
        if(block.type == 'numbered_list_item_group' || block.type == 'bulleted_list_item_group'){
            block.items.forEach((item) => {
                if(item.children != false){
                    const result = listMergerHandler(item.children);
                    item.children = result;
                }
            })
        }
    })
    return mergedContent;
}


fullPageContents = listMergerHandler(fullPageContents)

// console.log("this is the full")
// console.log(JSON.stringify(fullPageContents))
// console.log("==================================")



function tocGenerator(pageContents){
    console.log("Generating table of contents...")
    const headingTypes = ['heading_1', 'heading_2', 'heading_3'];
    const headingLevel = {
        'heading_1': 1,
        'heading_2': 2,
        'heading_3': 3
    }

    let listItems = [];
    pageContents.forEach((item) => {
        if(headingTypes.includes(item.type)){
            const text = item.text.map((span) => span.content);
            listItems.push( {
                level: headingLevel[item.type],
                id: item.id,
                text: text.join('')
            } );
        }
    })
    return listItems;
};

fullPageContents.forEach((item) => {
    if(item.type == 'table_of_contents'){
        item.listItems = tocGenerator(fullPageContents);
    }
});

const pageTitle = pageInfoData.properties.Name.title[0].plain_text;
let createdDate = 'Unspecified';
let createdTime = 'Unspecified';

if(pageInfoData.properties['Original Create Time'].date == null){
    ({ date: createdDate, time: createdTime } = dateFormatter(pageInfoData.created_time))
}else{
    ({ date: createdDate, time: createdTime } = dateFormatter(pageInfoData.properties['Original Create Time'].date.start))
}

const pageTitleEle = pageTitle + " - " + getTitle.get();

---
<link rel="icon" type="image/svg+xml" href={ pageIcon } />
<title>{ pageTitleEle }</title>

<Framework tester="asdasda">
    <div class="header-image" style={ "background-image: url(" + pageCover + ")" } >
        <div>
            <h1 class="page-title bg-body">{ pageTitle }</h1>
            <i class="page-title bg-body">Create At: { createdDate + ' ' + createdTime } </i>
        </div>
    </div>

    <div class="container">
        {
            fullPageContents.map((block) =>(
                <Block block={block}></Block>
            ))
        }
    </div>
</Framework>